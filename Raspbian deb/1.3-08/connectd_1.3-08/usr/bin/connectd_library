#  connectd_library
#
#  Provides library functions to install, configure or remove remot3.it connectd
#  attachment services for tcp listeners.
#  Interactive and preconfigured modes supported.
#
#  connectd by remot3.it, Inc. 
#  Copyright 2017. All rights reserved.

##### Settings #####
LIBVERSION=lib_v1.3-08
AUTHOR="Gary Worsham"
LIBMODIFIED="December 05, 2017"
DAEMON=connectd
GREPFLAGS=
CURL_OPTS="-k -s -S -X"

filename=$(basename "$0")

#-------------- Global Variables
token=""

# ----------------------------------------
STARTEMUP=connectd_start

# ----------------------------------------
# web API URLs

version=apv/v24.3
server=api01.remot3.it

loginURL=https://$server/$version/user/login
loginAuthURL=https://$server/$version/user/login/authhash
versionURL=https://$server/$version/version/PI_INSTALLER
unregdeviceURL=https://$server/$version/device/list/unregistered
preregdeviceURL=https://$server/$version/device/create
deleteURL=https://$server/$version/device/delete
connectURL=https://$server/$version/device/connect
deviceURL=https://$server/$version/device
deviceHWIDURL=https://$server/$version/developer/device/hardwareid
regAccountURL=https://$server/$version/user/create/verify
regAccountURLVerified=https://$server/$version/user/create/verified
regdeviceURL=https://$server/$version/device/register

# ----------------------------------------
##### End Settings #####

##### Version #####
displayVersion()
{
    printf "remot3.it connection installer Version: %s %s \n" "$VERSION" "$LIBVERSION"
    printf "Modified: %s (library) %s \n" "$MODIFIED" "$LIBMODIFIED"
    printf "Build date: %s " "$BUILDDATE"
}
##### End Version #####

##### checkForRoot #####
checkForRoot()
{
    # check for su user at this point
    if ! [ "$(id -u)" = 0 ]; then
        echo "Running this program requires root access." 1>&2
        echo "Please run sudo $0 instead of $0." 1>&2
	exit 1
    fi
}
##### End Version #####

##### checkForUtilities #####
# confirm presence of required utilities for installer to work

checkForUtilities()
{
    # check for curl with SSL
    curl --version | grep SSL &> /dev/null
    if [ $? -ne 0 ]; then
        echo "Running this program requires curl with SSL support." 1>&2
        echo "Please install curl with SSL support." 1>&2
        echo "Contact support@remot3.it if you are not sure what to do." 1>&2
	exit 1
    fi
}
##### End checkForUtilities #####

#### check for updated installer
# as written this only works on Debian operating systems
# CHECKFORDEB should be set in calling script

checkForUpdate()
{
    if [ "$CHECKFORDEB" = "1" ]; then
        echo
        echo "-------------------"
        echo  
        dpkg --status "$PACKAGE" 2> "$TMP_DIR"/pkgcheck 
        isItInstalled="$?"
        if [ "$isItInstalled" -eq 1 ]; then
            echo "$PACKAGE is not yet installed."
	    return
        fi 
        currentlyInstalled=$(dpkg --status "$PACKAGE" | grep Version | awk '{ print $2 }')
        echo "$PACKAGE version $currentlyInstalled is currently installed."

        # check to see if updated version exists
        resp=$(curl ${CURL_OPTS} GET -H "content-type:application/json" -H "developerkey:$developerkey"  -H "token:$token" "$versionURL")
        checkAPIResult "$versionURL" "$resp"
        package=$(jsonval "$resp" "component")
        latestVer=$(jsonval "$resp" "version")
        echo    
        echo "$latestVer is the most recent version of $package available from the Raspbian repository."
        if [ "$currentlyInstalled" != "$latestVer" ]; then
    	    downloadMsg=$(jsonval "$resp" "description")
    	    echo "A new installer is available at $downloadMsg"
            if ask "Would you like to download and install this file now?"; then
                cd /tmp
                wget "$downloadMsg" -O "$TMP_DIR"/connectdpackage.deb
                dpkg -i "$TMP_DIR"/connectdpackage.deb &
                exit
           fi
        fi
    fi
}

##### end of check for update

################### mv utility (some platforms don't support it)

mv()
{
	cp "$1" "$2"
	rm "$1"
}


##### Compatibility checker #####
connectdCompatibility()
{
    printf "\nChecking the daemon for compatibility... \n\n"
    "$BIN_DIR"/"$DAEMON"."$PLATFORM" -n > "$TMP_DIR"/.testdaemon
    if [ $? -ne 0 ]; then
        echo "The supplied daemon $DAEMON.$PLATFORM is not compatible with this device."
        echo "Please contact support@remot3.it with the following information:"
        cat /proc/cpuinfo
        exit 1
    else
        echo "Using architecture $PLATFORM..."
    fi
    printf "\nChecking your network for compatibility... \n\n"
    grep OK "$TMP_DIR"/.testdaemon > "$TMP_DIR"/.networkDump
    number=$(cat "$TMP_DIR"/.networkDump | wc -l)

    if [ "$number" -ge 3 ]; then
        printf "Your network is compatible with remot3.it services.\n\n"
        sleep 1
    elif [ "$(grep "$TMP_DIR/.networkDump" "Send to" | grep -c "OK" )" -lt 1 ]; then
        printf "Unfortunately, it appears your network may not currently be compatible with remot3.it services.\n"
        printf "Please contact support@remot3.it for help.\n\n"
        exit 1
    fi
}
##### End Compatibility checker #####

##### get HardwareID address #####
# HardwareID is a UUID concatenated with eth0 MAC address
# if the file /etc/connectd/serial.txt does not exist, create the
# value and write it there.  Otherwise read the value from then
# file.
# mac is also determined here as it is used for the SERVICEBASENAME
# in connectd_register
getHardwareID()
{
# expression for mac is set in connectd_options
    if [ -f "$HARDWAREIDFILE" ]; then
	HardwareID=$(cat "$HARDWAREIDFILE")
    else
    	num=20
    	random=$(tr -cd A-Za-z0-9 < /dev/urandom | dd bs=$num count=1 2> /dev/null)
	HardwareID="$mac-$random"

	echo "$HardwareID" > "$HARDWAREIDFILE"
	chmod -w "$HARDWAREIDFILE"
    fi
    debug "remot3.it HardwareID is $HardwareID"
    logger "remot3.it HardwareID is $HardwareID"
}

##### end get HardwareID address #####


##### factory reset - doesn't actually do anything at present
factoryReset()
{
    for f in "$CONNECTD_DIR"/*.conf ; do
	printf "%s\n" "$f"
    done 
}
##### end of factory reset

##### Check for existing services #####
checkforServices()
{
    services="$CONNECTD_DIR/Connectd*.conf"
    firstFile=$(echo "$services" | awk '{print $1}')
	echo "" > "$TMP_DIR"/.uidlist.txt
    if [ -e "$firstFile" ]; then
	ls "$CONNECTD_DIR/Connectd*.conf" > "$TMP_DIR/.legacy_instances"
	instanceNumber=$(wc "$TMP_DIR/.legacy_instances" -l)
	if [ -f "$TMP_DIR/.instances" ]; then
	    rm "$TMP_DIR/.instances"
	fi
	echo "" > "$TMP_DIR/.instances"
	for i in $(seq 1 "$instanceNumber"); do
	    instanceName=$(awk "NR==$i" "$TMP_DIR"/.legacy_instances | xargs basename | awk -F "." '{print $1}')
	    echo "$instanceName" >> "$TMP_DIR/.instances"
	done 
    else
	echo "" > "$TMP_DIR/.legacy_instances"
	echo "" > "$TMP_DIR/.instances"
    fi
    legacyInstances=$(cat "$TMP_DIR"/.instances)
    echo
    echo "===========  Installed remot3.it Services  ================="
    printf "Protocol\tPort\tService\t\tremot3.it Service Name\n"
    echo "------------------------------------------------------------"
    WARNING="0"
    confFiles=$(find "$CONNECTD_DIR" -name "*.conf")
    DeviceName=""

#    echo $confFiles
    for file in $confFiles; do
#	debug $file
        uid="$(grep '^UID' "$file" | awk '{print $2}')"
	echo "$uid" >> "$TMP_DIR"/.uidlist.txt

        if [ "$uid" != "" ]; then
            port="$(grep '^port' "$file" | awk '{print $2}')"
	    debug "$port"
            yooareell="$deviceURL/$uid"
            debug "$yooareell"

	    resp=$(curl ${CURL_OPTS} GET -H "content-type:application/json" -H "developerkey:$developerkey"  -H "token:$token" "$yooareell")
            checkAPIResult "$yooareell" "$resp"

	    # this next test checks to see if device is registered.  
	    # If not, it was probably deleted at the web portal.

	    unknownDevice=$(echo "$resp" | grep "unknown device")
            if [ "$unknownDevice" = "" ]; then

	        serviceName=$(jsonval "$resp" "name")

		debug "serviceName: $serviceName"
            
	        protocol=$(jsonval "$resp" "title")

		debug "protocol: $protocol"

	        # infer standard port assignments from service type embedded into server response

                if [ "$protocol" = "Bulk Service" ]; then
		    protocol="rmt3"
		    port=65535
                elif [ "$protocol" = "SSH" ]; then
                    port=22
                elif [ "$protocol" = "Basic Web" ]; then
		    protocol="WebPxy"
                    port=80
                elif [ "$protocol" = "HTTP" ]; then
                    port=80
                elif [ "$protocol" = "VNC" ]; then
                    port=5901
	        # trim this one's name so it fits on display
                elif [ "$protocol" = "Generic TCP" ]; then
                    protocol="TCP"
                fi

	        #if conf file has port override, use that instead

                port_override=$(grep proxy_dest_port "$file" | awk '{print $2}')

                if [ "$port_override" != "" ]; then    
                    port=$port_override
                fi 

	        # get service process name which is using that tcp port, if any

                service=$(netstat -apn 2> /dev/null | grep ${GREPFLAGS} tcp | grep ${GREPFLAGS} "0.0.0.0:$port" | grep LISTEN | awk -F"/" '{print $2}')

	        # if no service, show warning
                if [ "$service" = "" ]; then
		    if [ "$protocol" != "rmt3" ]; then
                        service="WARNING-NONE"
		        WARNING="1"
		    fi
                fi
		# don't show rmt3 service in Service List - it's the "Device Name"
                if [ "$protocol" != "rmt3" ]; then
                    printf "%s\t\t%s\t%s\t%s\n" "$protocol" "$port" "$service" "$serviceName"
		else
		    DeviceName="$serviceName"
                fi
            else
               printf "Warning - %s is not registered to this account.\n" "$file"
            fi
        fi
    done
    echo "------------------------------------------------------------"
    echo " Device Name: $DeviceName"
    echo "============================================================"

    if [ "$WARNING" = "1" ]; then
        printf "WARNING-NONE indicates that there is no TCP listener \n"
        printf "detected at that port. Please check your settings.\n"
        echo "============================================================"
    fi
    printf "\n"
}
##### End Check for existing services #####

######## get a number withing a given range
### e.g. getNumRange 2 5 will ask you for a number between 2 and 5

getNumRange()
{
     validInput="n"
        while [ "$validInput" = "n" ]; do
            echo "Please select from the above options ($1 - $2):"
            read num
            echo
            if [ $(validateInput "$num" "0123456789") -ne 0 ]; then
	        printf "\nSorry, enter numbers only.\n"
	    else
#		echo "You entered: $num"
                if [ "${num}" -ge "$1" ]; then
                   if [ "${num}" -le "$2" ]; then
                      validInput="y"
                   fi
                fi
            fi
        done
        return "$num"
}


########## Begin menuLoop #################
menuLoop()
{
    while [ true ]; do
   #     clear
        checkforServices
	alias=""	# reset alias,so you will be asked
        printf "********************** Main Menu *************************\n"
        printf "                                                         \n"
        printf "      1) Attach/reinstall remot3.it to a Service         \n"
        printf "      2) Remove remot3.it attachment from a Service      \n"
        printf "      3) Remove all remot3.it attachments, then exit     \n"
        printf "      4) Exit                                            \n"
        printf "                                                         \n"
        printf "**********************************************************\n"
        printf "Platform: %s\n" " $PLATFORM"
        printf "**********************************************************\n\n"

        getNumRange 1 4
        get_num=$?

        if [ "$get_num" = 1 ]; then
            protocolSelection
# in protocolSelection, get_num will be set to MAXSEL to indicate "return to previous menu"
            if [ "$get_num" != "$MAXSEL" ]; then
            	configureConnection
            fi
        elif [ "$get_num" = 2 ]; then
            deleteConnection
        elif [ "$get_num" = 3 ]; then
            deleteAllConnections
        elif [ "$get_num" = 4 ]; then
            exit
        fi
    done
}

############# End menuLoop #######################

#### Platform detection #####
platformDetection()
{
    if [ "$PLATFORM" != "" ]; then
        return
    fi
    machineType="$(uname -m)"
    osName="$(uname -s)"
    board="$(uname -a | awk '{ print $2 }')"

    if [ -f "/etc/os-release" ]; then
        distributionName=$(grep ID_LIKE= /etc/os-release | grep -v VERSION | awk -F "=" '{print $2}')
    fi
    if [ "$machineType" = "armv6l" ]; then
        PLATFORM=pi
        SYSLOG=/var/log/syslog
    elif [ "$machineType" = "armv7l" ]; then
	if [ "$distributionName" = "ubuntu" ]; then
        # ubuntu is put in there for Wandboard, but no reason to use anything other than Pi daemons etc.
		PLATFORM=pi
	else 
		if [ "$board" = "beaglebone" ]; then
			PLATFORM=beagle
		else
        		PLATFORM=pi
		fi
	fi
        SYSLOG=/var/log/syslog
    elif [ "$machineType" = "x86_64" ]; then
	if [ "$distributionName" = "debian" ]; then
		PLATFORM="i686"
	else 
        	PLATFORM="i686"
	fi
        SYSLOG=/var/log/syslog
    else
        printf "Sorry, you are running this installer on an unsupported device. But if you go to \n"
        printf "http://forum.connectd.com we'll be happy to help you get your device up and running. \n\n"
        printf "Please supply the following information: \n\n"
        uname -a
        cat /proc/cpuinfo
        printf "Thanks! \n"
        exit
    fi

    #   printf "Detected platform type: %s \n" "$PLATFORM"
    #   printf "Using %s for your log file \n\n" "$SYSLOG"
}
##### End Platform detection #####

##### Protocol selection #####
protocolSelection()
{
    CONNECTD_PORT=""
    CUSTOM=0
    
     #   clear
    checkforServices
    printf "\n\n"
    printf "*********** Protocol Selection Menu ***********\n"
    printf "                                             \n"
    printf "     1) SSH on port 22                       \n"
    printf "     2) Web (HTTP) on port 80                \n"
    printf "     3) VNC on port 5901                     \n"
    printf "     4) Custom (TCP)                         \n"
    printf "     5) Return to previous menu              \n"
    printf "                                             \n"
    printf "***********************************************\n\n"
    printf " You can change the port value during install  \n\n"
    printf "***********************************************\n\n"
    MAXSEL=5
    unset get_port

    getNumRange 1 "$MAXSEL"
    get_num=$?

    printf "You have selected: %s. \n\n" "${get_num}"
    if [ "$get_num" = 1 ]; then
        PROTOCOL=ssh
        printf "The default port for SSH is 22.\n"
        if ask "Would you like to continue with the default port assignment?"; then
            PORT=22
        else
            CUSTOM=2
            getNumRange 1 65535    
            PORT=$?
        fi
        CONNECTD_PORT=Connectd"$PROTOCOL""$PORT"
    elif [ "$get_num" = 2 ]; then
        PROTOCOL=web
        printf "The default port for Web (http) is 80.\n"
        if ask "Would you like to continue with the default port assignment?"; then
            PORT=80
        else
            CUSTOM=2
            getNumRange 1 65535    
            PORT=$?
        fi
        CONNECTD_PORT=Connectd"$PROTOCOL""$PORT"
    elif [ "$get_num" = 3 ]; then
        PROTOCOL=vnc
        printf "The default port for VNC (tightVNC) is 5901.\n"
        if ask "Would you like to continue with the default port assignment?"; then
            PORT=5901
        else
            CUSTOM=2
            getNumRange 1 65535    
            PORT=$?
       fi    
        CONNECTD_PORT=Connectd"$PROTOCOL""$PORT"
    elif [ "$get_num" = 4 ]; then
        CUSTOM=1
        if ask "Does this protocol use a web browser (e.g. HTTP on port 8080 vs. 80)"; then
            PROTOCOL=web
        else
            PROTOCOL=tcp
        fi
        printf "Please enter the protocol name (e.g., ssh, http, nfs): \n"
        read port_name
        CUSTOM_PROTOCOL="$(echo "$port_name" | tr 'A-Z' 'a-z' | tr -d ' ')"
        getNumRange 1 65535    
        PORT=$?
        CONNECTD_PORT=Connectd"$CUSTOM_PROTOCOL""$PORT"
    fi
# process the entry for all menu choices other than MAXSEL  
    if [ "$get_num" != "$MAXSEL" ]; then
      #  clear
        printf "We will attach a remot3.it connection to the following service:\n\n"
        if [ "$CUSTOM" = 1 ]; then
            printf "Protocol: %s " "$CUSTOM_PROTOCOL"
        else
            printf "Protocol: %s " "$PROTOCOL"
        fi
        if [ "$PROTOCOL" != "rmt3" ]; then
            printf "\nPort #: %s\n" "$PORT"
	fi
            
	alreadyThere=$(grep $GREPFLAGS "$CONNECTD_PORT" "$TMP_DIR/.legacy_instances")
        if [ "$alreadyThere"  != "" ]; then
            printf "remot3.it is already attached to this Service.\n" 
            if ask "Do you wish to overwrite your previous settings?"; then
                testLogin
                deleteDevice
                if [ -f "$PID_DIR"/"$CONNECTD_PORT".pid ]; then
                    if [ -f "$BIN_DIR"/"$CONNECTD_PORT" ]; then
                        "$BIN_DIR"/"$CONNECTD_PORT" stop -q > /dev/null
                    else
                        if ask "May we stop all remot3.it services to continue?"; then
                            killall connectd
                            echo "Run $STARTEMUP to restart all installed remot3.it Services."
                        fi
                        if [ -f "$PID_DIR"/"$CONNECTD_PORT".pid ]; then
                            rm "$PID_DIR"/"$CONNECTD_PORT".pid
                        fi
                    fi
                fi
            else 
                printf "We will allow you to re-select your desired service to install... \n\n"
                protocolSelection
            fi
        else
		#     userLogin
            testLogin
        fi
    fi
}
##### End Protocol selection #####


############ checkAPIResult ############
# checks return value of API calls.  
# if status = true, just returns silently
# if status = false, reason is displayed and script pauses
# first parameter is something to display, usually the URL
# second parameter is full JSON response

checkAPIResult()
{
    result=$(jsonval "$2" 'status')
    if [ "$result" = "true" ]; then
        return
    else
        echo "API call to $1 failed!"
        reason=$(jsonval "$2" 'reason')
        echo "$reason"
#        echo "Hit any key to continue."
#	read key
    fi
}

###### End of checkAPIResult #######

##### Delete Connection
deleteConnection()
{
    printf "\nEnter the remot3.it Name of the Service you wish to detach.\n"
    printf "This will not affect the installed service.\n"
    read deviceToDelete
    deviceFound=0

    # now iterate through known connections to find it

    for file in "$CONNECTD_DIR"/*.conf; do
        uid="$(grep '^UID' "$file" | awk '{print $2}')"
	yooareell="$deviceURL/$uid"

	resp=$(curl ${CURL_OPTS} GET -H "content-type:application/json" -H "developerkey:$developerkey"  -H "token:$token" "$yooareell")

        serviceName=$(jsonval "$resp" "name")

        if [ "$serviceName" = "$deviceToDelete" ] && [ "$serviceName" != "$DeviceName" ]; then  
	    #      printf "\n$deviceInfo found...\n"
            deviceFound=1
	    # get the protocol name
	    deviceType=$(jsonval "$resp" "title")
	    if ask "Are you sure you want to delete the remot3.it $deviceType attachment $serviceName?"; then
		printf "Deleting %s...\n" "$serviceName"
		result=$(curl ${CURL_OPTS} 'POST' $deleteURL -d "{\"deviceaddress\":\"$uid\"}" -H "Content-Type:application/json" -H "developerkey:$developerkey" -H "token:$token")

                checkAPIResult "$deleteURL" "$result"

 		fileNameRoot=$(echo "$file" | awk -F "." '{print $1}')
#		echo $fileNameRoot
 		# if daemon pid exists, stop daemon and remove start/stop script
 		if [ -f "$PID_DIR"/"$fileNameRoot".pid ]; then
 		    if [ -f "$BIN_DIR"/"$fileNameRoot" ]; then
 			"$BIN_DIR"/"$fileNameRoot" stop -q
 			rm "$BIN_DIR"/"$fileNameRoot"
		    fi
		fi
		if [ -f "$file" ]; then
		    rm "$file"
		fi
           fi
        fi
    done
    if [ "$deviceFound" -eq 0 ]; then
        echo "Sorry, could not find $deviceToDelete."
        echo "Please check your spelling and try again."
        echo "Press the 'Enter' key to return to the menu."
        read
    fi
}

##### End of Delete Connection

##### Delete All Connections
deleteAllConnections()
{
    if ask "Are you sure you want to delete ALL remot3.it attachments?"; then

    # now iterate through all enablement files to find it
    # stop all daemons.  

	"$BIN_DIR"/connectd_stop

    	for file in "$CONNECTD_DIR"/*.conf; do
	# get service name from UID
            uid="$(grep '^UID' "$file" | awk '{print $2}')"
	    resp=$(curl ${CURL_OPTS} GET -H "content-type:application/json" -H "developerkey:$developerkey"  -H "token:$token" "$deviceURL/$uid")
            serviceName="$(jsonval "$resp" name)"

	    printf "\nDeleting %s...\n" "$serviceName"
	
	    result=$(curl ${CURL_OPTS} 'POST' $deleteURL -d "{\"deviceaddress\":\"$uid\"}" -H "Content-Type:application/json" -H "developerkey:$developerkey" -H "token:$token")
            checkAPIResult "$deleteURL" "$result"

	    fileNameRoot=$(echo "$file" | awk -F "." '{print $1}')
#		    echo $fileNameRoot
 	    # if daemon pid exists, stop daemon and remove start/stop script
 	    if [ -f "$PID_DIR"/"$fileNameRoot".pid ]; then
 	        if [ -f "$BIN_DIR"/"$fileNameRoot" ]; then
 		    "$BIN_DIR"/"$fileNameRoot" stop -q
 		    rm "$BIN_DIR"/"$fileNameRoot"
		fi
	    fi
	    if [ -f "$file" ]; then
		rm "$file"
	    fi
       done
        if [ -f "$BIN_DIR"/"$STARTEMUP" ]; then
	    rm "$BIN_DIR"/"$STARTEMUP"
            rm "$BIN_DIR"/Connectd*
   	fi
# also should clear out crontab at this point
	disableStartup
# remove serial.txt
        if [ -f "$HARDWAREIDFILE" ]; then
	    rm "$HARDWAREIDFILE"
   	fi
    fi
    exit
}

##### End of Delete All Connections

##### Check for Bash #####
bashCheck()
{
    if [ "$BASH_VERSION" = '' ]; then
#	clear
	printf "You executed this script with dash vs bash! \n\n"
	printf "Please execute \"chmod +x %s \" and then \n" "$filename"
	printf "execute \"./%s\".  \n\n" "$filename"
	printf "Thank you! \n"
	exit
    else
	echo "Now launching the remot3.it connectd daemon installer..." > /dev/null
    fi
}
##### End Bash Check #####

######### Begin askRegisterLogin #########
askRegisterLogin()
{
	value="false"
	while [ "$value" = "false" ]; do
   #     clear
#        printf "\n\n"
        printf "********************* Sign In Menu *********************\n"
        printf "                                                      \n"
        printf "     1) Sign in to your existing remot3.it account    \n"
        printf "     2) Request a code for a new remot3.it account    \n"
        printf "     3) Enter a verification code received in e-mail  \n"
        printf "     4) Exit                                          \n"
        printf "                                                      \n"
        printf "********************************************************\n\n"

        getNumRange 1 4    
        get_num=$?

#        printf "You have selected: %s. \n\n" "${get_num}"
        if [ "$get_num" = 2 ]; then
		registerUser
#		askVerificationCode
		value="false"
        elif [ "$get_num" = 1 ]; then
		userLogin
		testLogin
		value="true"
        elif [ "$get_num" = 3 ]; then
		if [ "$username" = "" ]; then
		    getEmail
		fi
                enterVerificationCode
#		value="true"
        elif [ "$get_num" = 4 ]; then
	    if ask "Are you sure?"; then
		exit
	    fi
	fi
	done
}

######### End askRegisterLogin #########

######### Begin getEmail #########
getEmail() 
{
    printf "Enter your e-mail address to create a new remot3.it account.\n"
    if [ "$USERNAME" != "" ]; then 
	username="$USERNAME"
    else        
	read username
    fi
}
######### End getEmail #########

######### Begin registerUser #########
registerUser()
{
    getEmail
    resp=$(curl ${CURL_OPTS} 'POST' $regAccountURL -d "{\"email\":\"$username\"}" -H "content-type:application/json" -H "developerkey:$developerkey" 2> "$TMP_DIR"/.curlerr)

    debug "$resp"
    value=$(jsonval "$resp" "status") 
    reason=$(jsonval "$resp" "reason") 
    if [ "$value" != "true" ]; then
    	echo "E-mail registration error: " "$reason"
    else
    	printf "\nA verification code has been sent to %s.\n" "$username"
    	printf "If you do not receive this e-mail with your code\n"
    	printf "within a few minutes, select option 2 to try again.\n"
    	printf "Once you receive the code, select option 3 to enter it.\n\n"
   fi
   printf "Press any key to continue."
   read anyKey
 }

######### End registerUser #########

######### Begin enterVerificationCode #########
enterVerificationCode()
{
    passwordOK=0
    printf "\nEnter the verification code which you received by e-mail.\n"
    read registrationCode
    while [ "$passwordOK" != 1 ]; do
        echo
    	getNewPassword
    done

     resp=$(curl ${CURL_OPTS} 'POST' $regAccountURLVerified -d "{\"email\":\"$username\", \"password\":\"$password\", \"shortcode\":\"$registrationCode\"}" -H "content-type:application/json" -H "developerkey:$developerkey" 2> "$TMP_DIR"/.curlerr)

    debug "$resp"
    value=$(jsonval "$resp" "status") 
    if [ "$value" != "true" ]; then
	reason=$(jsonval "$resp" "reason")
    	echo "Account registration error:" "$reason"
        echo "Hit any key to continue."
	value="false"
	read anyKey
    else
# now log in
	signInAPI
	testLogin
    fi
}

######### End enterVerificationCode #########

######### Begin getNewPassword #########
getNewPassword() {
    if [ "$PASSWORD" != "" ]; then
	password="$PASSWORD"
    else
	printf "\nChoose a password to use with your remot3.it account.\n"
	printf "It should be between 7 and 15 characters in length.\n"
	printf "Valid special characters are limited to ! . - @ _ $ \n"
	printf "Please enter it now:\n"
	password=""
#	read  -s password
	read  password  # adjust for ash/dash

        if [ $(validateInput "$password" "\$ \@ \! \- \_ \. [a-zA-Z0-9]") != 0 ]; then
	    printf "\nSorry, password contains one or more invalid characters.\n"
	    password=""
	    passwordOK=-1
	    return
	fi 

	l=${#password}
	# echo "Length of $password is $l".

	if test "$l" -ge 7 ||  "$l" -le 15 ; then
	    printf "\nPassword length should be between 7 and 15 characters.\n"
	    password=""
	    passwordOK=-1
	    return
	fi

        printf "\nPlease confirm your remot3.it password: \n"
        read passwordConfirm

        if [ "$password" != "$passwordConfirm" ]; then
	    echo
	    printf "Passwords don't match!"
	    echo
	    passwordOK=-1
        else
	    passwordOK=1
	fi
    fi
}

######### End getNewPassword #########

######### Begin Portal Login #########
userLogin () #Portal login function
{
#    echo "connectd_library Username = $USERNAME Password = $PASSWORD"

    if [ "$USERNAME" != "" ]; then 
	username="$USERNAME"
    else        
	printf "Please enter your remot3.it Username (e-mail address): \n"
	read username
    fi
    if [ "$AUTHHASH" != "REPLACE_AUTHHASH" ]; then
	authhash="$AUTHHASH"
    else
        if [ "$PASSWORD" != "" ]; then
	    password="$PASSWORD"
        else
	# use stty to suppress password, if stty exists.
            if [ "$(which stty)" != "" ]; then
                stty -echo
	    fi
	    printf "\nPlease enter your remot3.it password: \n"
	    password=""
	    read password
           if [ "$(which stty)" != "" ]; then
                stty echo
	    fi
        fi
   fi
   if [ "$DEVELOPERKEY" != "" ]; then 
       developerkey="$DEVELOPERKEY"
   else        
        printf "\nPlease enter your remot3.it Developer API key: \n"
	read developerkey
    fi
#   echo $username $password $authhash
   signInAPI
}
######### End Portal Login #########

####### SignInAPI ###################
signInAPI()
{
    debug "U:$username P:$password A:$authhash D:$developerkey"
    # if AUTHHASH is REPLACE_AUTHHASH it means user just wants to use password
    if [ "$AUTHHASH" = "REPLACE_AUTHHASH" ]; then
          resp=$(curl ${CURL_OPTS} 'POST' -H "developerkey: $developerkey" -H "Content-Type:application/json" -H "Cache-Control:no-cache" -d "{ \"username\" : \"$username\", \"password\" : \"$password\" }" "$loginURL" 2> "$TMP_DIR"/.curlerr)
    else
             resp=$(curl ${CURL_OPTS} 'POST' -H "developerkey: $developerkey" -H "Content-Type:application/json" -H "Cache-Control:no-cache" -d "{ \"username\" : \"$username\", \"authhash\" : \"$AUTHHASH\" }" "$loginAuthURL" 2> "$TMP_DIR"/.curlerr)
    fi
    checkAPIResult 'login' "$resp"

    status=$(jsonval "$resp" 'status')
    debug "Status = $status"
echo
echo

    token=$(jsonval "$resp" "token")
    debug "Login token: $token"
echo
echo
    if [ "$status" = 'true' ]; then
	token=$(jsonval "$resp" "token")
        debug "Login token: $token"
    else
    	loginFailed=$(echo "$resp" | grep "The username or password are invalid" | sed 's/"//g')
    	slimError=$(echo "$resp" | grep "Slim Application Error" | sed 's/"//g')
# 404 is triggered when you enter some special character in e-mail.  this specific search may fail if API
# server is moved
    	login404=$(echo "$resp" | grep "404 Page Not Found" | sed 's/"//g')
    	apikeyerror=$(echo "$resp" | grep "The API application key is invalid" | sed 's/"//g')
        devkeyerror=$(echo "$resp" | grep "api key failed validation" | sed 's/"//g')
	echo "Login Error: $loginFailed $slimError $login404 $apikeyerror $devkeyerror" 
    fi
    # invalid cert can happen if system date is set to before current date
    invalidCert=$(grep "SSL certificate problem" "$TMP_DIR"/.curlerr)
    date +"%s" > "$TMP_DIR"/.lastlogin
}
####### End SignInAPI ###################

######### Test Login #########
testLogin()
{
    while [ "$loginFailed" != "" ] || [ "$slimError" != "" ] || [ "$login404" != "" ] || [ "$apikeyerror" != "" ] || [ "$devkeyerror" != "" ]; do
#	clear
	printf "\n\nYou have entered either an incorrect username, password, or Developer API Key.\n"
        sleep 1
	printf "\nPlease try again.  Press the 'Enter' key to continue.\n"
        read dummyValue
        printf "\n\nOne moment please...\n"
        sleep 4
        developerkey=
	loginFailed=
        slimError=
        login404=
        apikeyerror=
        devkeyerror=
	userLogin
    done
    if [ "$invalidCert" != "" ]; then
 #       clear
        printf "The login security certificate is not valid.  This can be caused\n"
        printf "by your system date being incorrect.  Your system date is:\n%s\n\n" "$(date)"
        printf "Please correct the system date if needed and run the installer again.\n"
        printf "Run the command 'man date' for help resetting the date.\n\n"
        printf "If you are receiving this message and your system date is correct,\n"
        printf "please contact remot3.it support at forum.connectd.com.\n"
        exit
    fi
}
######### End Test Login #########

#### checkForDeviceName - looks to see if there is a registered rmt3 service
# if not, asks user to enter Device Name, which is used to register the rmt3 service
# when DeviceName is assigned, we then iterate through the other existing enablement files to 
# add the HWID to each, given the UID

checkForDeviceName()
{
# look for provisioning file corresponding to an existing Bulk Service
# (which is used to represent the Device Name)

    file="$CONNECTD_DIR"/Connectdrmt365535.conf
    if [ -f "$file" ]; then
#	echo "Found rmt3 conf file"
	debug "$file"
        uid="$(grep '^UID' "$file" | awk '{print $2}')"
	echo "$uid" >> "$TMP_DIR"/.uidlist.txt

        if [ "$uid" != "" ]; then
            port="$(grep '^port' "$file" | awk '{print $2}')"
	    yooareell="$deviceURL/$uid"

	    resp=$(curl ${CURL_OPTS} GET -H "content-type:application/json" -H "developerkey:$developerkey"  -H "token:$token" "$yooareell")
            checkAPIResult "$yooareell" "$resp"

	    # this next test checks to see if device is registered.  
	    # If not, it was probably deleted at the web portal.

	    unknownDevice=$(echo "$resp" | grep "unknown device")
            if [ "$unknownDevice" = "" ]; then
	        serviceName=$(jsonval "$resp" "name")
		debug "serviceName: $serviceName"
            
	        protocol=$(jsonval "$resp" "title")
		debug "protocol: $protocol"
            fi
        else
            echo "UID $uid was not pre-registered successfully."
            logger "UID $uid was not pre-registered successfully."
            echo "Please contact support@remot3.it."
            exit 1
        fi
    else	# register the device using an RMT3 service
#	echo "Did not find rmt3 conf file"
        PROTOCOL=rmt3
        PORT=65535
        CONNECTD_PORT=Connectd"$PROTOCOL""$PORT"
        configureConnection
	# now iterate through existing conf files, skipping rmt3 one, and add HWID to others
    	convertExistingUIDs

    fi
}

#=======================================
convertExistingUIDs()
{
# check to make sure there is an existing directory before trying to iterate.
    if [ -d "$CONNECTD_DIR" ]; then
        logger "updating existing services to add HWID"
    	for file in "$CONNECTD_DIR"/*.conf; do
	    debug "$file"
            if [ "$file" != Connectdrmt365535.conf ]; then
	# get service name from UID
                uid="$(grep '^UID' "$file" | awk '{print $2}')"

                result=$(curl ${CURL_OPTS} 'POST' $deviceHWIDURL -d "{\"deviceaddress\":\"$uid\", \"hardwareid\":\"$HardwareID\"}" -H "Content-Type:application/json" -H "developerkey:$developerkey" -H "token:$token" 2> /"$TMP_DIR"/.curlerr)

                checkAPIResult "$deviceHWID" "$result"

	        addHWIDResult=$(jsonval "$result" "status")

		echo "Updating $file"
	        logger "connectd: Adding HWID $HardwareID to $serviceName UID $uid - $addHWIDResult"
# now update start/stop script
		CONNECTD_PORT=$(basename "$file" ".conf")
		installStartStop
            fi
        done
    fi
}

######### Install Enablement #########
# we install .conf file temporarily in $TMP_DIR and add UID and secret
# before copying it to $CONNECTD_DIR
installEnablement()
{
    printf "."
    if [ ! -d "CONNECTD_DIR" ]; then
	mkdir -p "$CONNECTD_DIR"
    fi

#
# if REGISTERSERVICE==1, then we copy the template enablement file to /tmp where further things happen
# before it is copied into place.  Otherwise we copy the template file directly to CONNECTD_DIR
#
    if [ "$REGISTERSERVICE" = "1" ]; then
        cat "$CONNECTD_LIB_DIR"/conf/"$PROTOCOL".pi > "$TMP_DIR"/"$CONNECTD_PORT".conf
    else
        cat "$CONNECTD_LIB_DIR"/conf/"$PROTOCOL".pi > "$CONNECTD_DIR"/"$CONNECTD_PORT".conf
    fi
}
######### End Install Enablement #########

######### Add line to cron ######
cronAddLine()
{
    crontab -l 2>/dev/null 1> "$TMP_DIR"/.crontab_old
    echo "$1" >> "$TMP_DIR"/.crontab_old
    logger "cronAddline $1"
    crontab "$TMP_DIR"/.crontab_old
}
######### End add line to cron ######

######### Disable Connectd services to start at reboot time ######
cronRemoveLine()
{
    crontab -l | grep -v "$1" | cat > "$TMP_DIR"/.crontmp
    crontab "$TMP_DIR"/.crontmp
}

######### Enable remot3.it services to start at reboot time ######
enableStartup()
{
    if [ $startupScripts = 3 ]; then
        cronAddLine "@reboot $BIN_DIR/$STARTEMUP"
    elif [ $startupScripts = 1 ]; then
        echo "You will need to add reboot start/stop links to $BIN_DIR/$STARTEMUP"
    fi
}
######### End Enable remot3.it services to start at reboot time ######

######### Disable remot3.it services to start at reboot time ######
disableStartup()
{
    if [ $startupScripts = 3 ]; then
        cronRemoveLine "@reboot $BIN_DIR/$STARTEMUP"
    elif [ $startupScripts = 1 ]; then
        echo "You will need to remove reboot start/stop links to $BIN_DIR/$STARTEMUP"
    fi
}

#----------  setBASEDIR --------------
# this function adds the correct BASEDIR to the file in question
# BASEDIR is defined in connectd_register and connectd_installer

setBASEDIR()
{
# echo "setBASEDIR for $1"
    # have to escape slashes / in path to send string to sed
    BASEDIRSTRING=$(echo "$BASEDIR" | sed 's/\//\\\//g')
    cat "$1" | sed "/BASEDIR=/c\BASEDIR=$BASEDIRSTRING/" > "$TMP_DIR"/setBASEDIR.tmp 
    cp "$TMP_DIR"/setBASEDIR.tmp "$1" 
}

#----------  end of setBASEDIR --------------

######### Install Start/Stop Scripts #########
installStartStop()
{
    printf "."
    sed s/CONNECTD_PORT=/CONNECTD_PORT="$CONNECTD_PORT"/ < "$CONNECTD_LIB_DIR"/scripts/launch_connectd > "$TMP_DIR"/"$CONNECTD_PORT"
    cat "$TMP_DIR"/"$CONNECTD_PORT" > "$BIN_DIR"/"$CONNECTD_PORT"
    setBASEDIR "$BIN_DIR"/"$CONNECTD_PORT"
    chmod +x "$BIN_DIR"/"$CONNECTD_PORT"
# create the startup file if it does not exist.
    if [ ! -f "$BIN_DIR"/$STARTEMUP ]; then
        cp "$CONNECTD_LIB_DIR"/scripts/$STARTEMUP "$BIN_DIR"
#     printf "$STARTEMUP copied to %s\n" "$BIN_DIR"
    fi
    # 3: crontab approach
    if [ $startupScripts = 3 ]; then
	checkCron=$(crontab -l 2> /dev/null | grep -c "$STARTEMUP" )
	debug "CheckCron: $checkCron\n"
	if [ "$checkCron" = 0 ] && [ "$STARTDAEMONSONREBOOT" = "1" ]; then
	    enableStartup
	fi
	if [ "$checkCron" -gt 0 ] && [ "$STARTDAEMONSONREBOOT" = "0" ]; then
	    disableStartup
	fi
 #   elif [ $startupScripts = 1 ]; then
 #       ln -s /usr/bin/connectd_start /etc/init.d/connectd
    fi
    # see if there is an entry to start the chosen service daemon already
    checkStartConnectd=$(grep -c "$CONNECTD_PORT" "$BIN_DIR"/"$STARTEMUP" )
    # if not, add it
    if [ "$checkStartConnectd" = 0 ]; then
	sed s/REPLACE_TEXT/"$CONNECTD_PORT"/ < "$CONNECTD_LIB_DIR"/scripts/connectd_start.add > "$TMP_DIR"/connectd_start.add
	sh -c "cat $TMP_DIR/connectd_start.add >> $BIN_DIR/$STARTEMUP"
        rm "$TMP_DIR"/connectd_start.add
    fi
    # see if there is an entry to start the listener service daemon schannel.x already
    checkStartSchannel=$(grep -c "connectd_schannel" "$BIN_DIR"/"$STARTEMUP" )
    # if not, add it
    if [ "$checkStartSchannel" = 0 ]; then
        sh -c "echo '"$BIN_DIR/connectd_schannel" start' >> $BIN_DIR/$STARTEMUP"
    fi
    setBASEDIR "$BIN_DIR"/"$STARTEMUP"
    chmod +x "$BIN_DIR"/"$STARTEMUP"

    # copy the template connectd_stop then update the BASEDIR variable
    if [ ! -e "$BIN_DIR"/connectd_stop ]; then
        cp "$CONNECTD_LIB_DIR"/scripts/connectd_stop "$BIN_DIR"
        setBASEDIR "$BIN_DIR"/connectd_stop
        chmod +x "$BIN_DIR"/connectd_stop
    fi

    # copy the template connectd_schannel then update the BASEDIR variable      
    if [ ! -e "$BIN_DIR"/connectd_schannel ]; then
        cp "$CONNECTD_LIB_DIR"/scripts/connectd_schannel "$BIN_DIR"
        setBASEDIR "$BIN_DIR"/connectd_schannel
        chmod +x "$BIN_DIR"/connectd_schannel
    fi
}
######### End Start/Stop Scripts #########

######### Fetch UID #########
fetchUID()
{
    printf "."
    "$BIN_DIR"/"$DAEMON"."$PLATFORM" -life -1 -f "$TMP_DIR"/"$CONNECTD_PORT".conf > "$TMP_DIR"/.DeviceTypeString
    DEVICETYPE="$(grep DeviceType "$TMP_DIR"/.DeviceTypeString | awk -F "=" '{print $2}')"
    rm "$TMP_DIR"/.DeviceTypeString
}
######### End Fetch UID #########

######### Check for UID #########
checkUID()
{
    printf "."
    checkforUID="$(tail "$TMP_DIR"/"$CONNECTD_PORT".conf | grep -c UID )"
    if [ "$checkforUID" = 2 ]; then
	#    cp "$CONNECTD_LIB_DIR"/"$CONNECTD_PORT".conf /"$CONNECTD_DIR"/
	uid=$(grep ^UID "$TMP_DIR"/"$CONNECTD_PORT".conf | awk '{print $2}' )
	printf "\n==========================================\nAllocated UID: %s. \n\n" "$uid"
    else
	retryFetchUID
    fi
}
######### Check for UID #########

######### Retry Fetch UID ##########
retryFetchUID()
{
    printf "."
    for run in $(seq 1 15)
    do
	fetchUID
	checkforUID="$(tail "$TMP_DIR"/"$CONNECTD_PORT".conf | grep -c UID)"
	if [ "$checkforUID" = 2 ]; then
	    #        cp "$CONNECTD_LIB_DIR"/"$CONNECTD_PORT".conf /"$CONNECTD_DIR"/
#	    uid="$(tail "$TMP_DIR"/"$CONNECTD_PORT".conf | grep UID | awk '{print $2}' | xargs echo)"
	    uid="$(grep ^UID "$TMP_DIR"/"$CONNECTD_PORT".conf | awk '{print $2}' )"
	    #       printf "\n\nAllocated UID: %s. \n\n" "$uid"
	    break
	fi
    done
    checkforUID="$(tail "$TMP_DIR"/"$CONNECTD_PORT".conf | grep -c UID )"
    if [ "$checkforUID" != 2 ]; then
	printf "We have unsuccessfully retried to obtain a UID.\n"
        printf "Please contact remot3.it Support at http://forum.connectd.com for help.\n\n"
    fi
}
######### Retry Fetch UID ##########

######### Pre-register Device #########

preregisterUID()
{
    printf "."
# echo "devicetype = $DEVICETYPE"

    preregUID="$(curl ${CURL_OPTS} 'POST' $preregdeviceURL -d "{\"deviceaddress\":\"$uid\", \"devicetype\":\"$DEVICETYPE\"}" -H "Content-Type:application/json" -H "developerkey:$developerkey" -H "token:$token")"
    checkAPIResult "$preregdeviceURL" "$preregUID"

    test1="$(echo "$preregUID" | grep -c "true" )"
    debug "$preregUID"
#    test2="$(echo "$preregUID" | grep -c -E "missing api token|api token missing")"
    test2="$(echo "$preregUID" | grep -c "api token")"
    test3="$(echo "$preregUID" | grep -c "false")"
    if [ "$test1" = 1 ]; then
	printf "Pre-registration of UID: %s successful. \n\n" "$uid" > /dev/null
    elif [ "$test2" = 1 ]; then
	printf "You are not currently logged in. \n"
	userLogin
	testLogin
	preregisterUID
    elif [ "$test3" = 1 ]; then
	printf "Sorry, the pre-registration of UID: %s is failing."
	printf "Please send an e-mail to support@remot3.it."

	overridePort
	startService
	exit
    fi
}
######### End Pre-register Device #########


######### registerDevice - Get Device Name #########

registerDevice()
{
    printf "."
    while [ "$alias" = "" ]; do
        if [ "$PROTOCOL" = "rmt3" ]; then
	    printf "\n\nEnter a name for your device (e.g. my_Pi_001).\n\n"
	    printf "The Device Name identifies your device in the remot3.it portal.\n"
            printf "Your services will be grouped under the Device Name.\n\n"
	else
	    printf "\n\nEnter a name for this remot3.it service (e.g. %s-Pi). \n" "$PROTOCOL"
	    printf "This name will be shown in your remot3.it Service List.\n\n"
        fi    
        printf "Only letters, numbers, underscore, space and dash are allowed.\n\n"
        read alias
        if [ $(validateInput "$alias" "\- \_ \. [a-zA-Z0-9]") != 0 ]; then
            printf "\nSorry, %s contains one or more invalid characters.\n\n" "$alias"
            alias=""
        fi
    done
    printf "."

    result=

    while [ "$result" != "true" ]; do

        if [ "$PROTOCOL" = "rmt3" ]; then
            secretCall="$(curl ${CURL_OPTS} 'POST' $regdeviceURL -d "{\"deviceaddress\":\"$uid\", \"devicealias\":\"$alias\", \"skipsecret\":\"true\", \"hardwareid\":\"$HardwareID\"}" -H "Content-Type:application/json" -H "developerkey:$developerkey" -H "token:$token")"    
        else
            secretCall="$(curl ${CURL_OPTS} 'POST' $regdeviceURL -d "{\"deviceaddress\":\"$uid\", \"devicealias\":\"$alias\", \"skipsecret\":\"true\", \"hardwareid\":\"$HardwareID\", \"skipemail\":\"true\"}" -H "Content-Type:application/json" -H "developerkey:$developerkey" -H "token:$token")"
        fi

        checkAPIResult "$regdeviceURL" "$secretCall"

        error="$(jsonval "$secretCall" "Error")"
        debug "Errors=$error"
    
        result="$(jsonval "$secretCall" "status")"
        if [ "$result" = "false" ]; then
            if [ "$error" = "DuplicateName:" ]; then
                echo
	        echo "There is already a Service registered to your account as $alias."
	        echo "Hit any key to continue."
	        read AnyKey
                alias=
                registerDevice
            elif [ "$error" = "DuplicateAddress:" ]; then
                echo
	        echo "Duplicate Address error while attempting to register $alias."
	        echo "Hit any key to continue."
	        read AnyKey
                exit 1
            else
                echo "Error: $regdeviceURL call failed."  
                reason=$(jsonval "$secretCall" "reason")
                echo "Reason was: $reason"
	        echo "Hit any key to continue."
	        read AnyKey
                exit 1
            fi
        else
    	    if [ "$result" = "true" ]; then
                secret="$(getJSONSecret "$secretCall" "secret")"
    	        echo "# password - erase this line to unregister the device" >> "$TMP_DIR"/"$CONNECTD_PORT".conf
	        echo "password $secret" >> "$TMP_DIR"/"$CONNECTD_PORT".conf
	    #       finally copy valid assembled enablement file to $CONNECTD_DIR
	        mv "$TMP_DIR"/"$CONNECTD_PORT".conf "$CONNECTD_DIR"/"$CONNECTD_PORT".conf
    	    fi
        fi

    done

    printf "Your Service Attachment will be called %s.\n\n" "$alias" > /dev/null
}
######### Get Device Name #########

######### Start Service #########
startService()
{
    printf "\n"
    logger "remot3.it Connection starting: $alias"
    echo "Registering $alias" ; sleep 1;printf ".";sleep 1;printf ".";sleep 1;printf ".";sleep 1;printf ".";sleep 1;printf ".";sleep 1;printf ".";sleep 1;printf ".";sleep 1; echo ; echo
    "$BIN_DIR"/"$CONNECTD_PORT" restart > /dev/null
}
######### End Start Service #########

######### Port Override #########
overridePort()
{
    if [ "$CUSTOM" = 1 ]; then
	cp "$CONNECTD_DIR"/"$CONNECTD_PORT".conf "$TMP_DIR"/
	echo "proxy_dest_port $PORT" >> "$TMP_DIR"/"$CONNECTD_PORT".conf
	mv "$TMP_DIR"/"$CONNECTD_PORT".conf "$CONNECTD_DIR"/
    elif [ "$CUSTOM" = 2 ]; then
	cp "$CONNECTD_DIR"/"$CONNECTD_PORT".conf "$TMP_DIR"/
	echo "proxy_dest_port $PORT" >> "$TMP_DIR"/"$CONNECTD_PORT".conf
	mv "$TMP_DIR"/"$CONNECTD_PORT".conf "$CONNECTD_DIR"/
    fi
}
######### End Port Override #########

######### Delete device #########
deleteDevice()
{
    uid=$(grep ^UID "$CONNECTD_DIR"/"$CONNECTD_PORT".conf | awk '{print $2}' )
    result=$(curl ${CURL_OPTS} 'POST' $deleteURL -d "{\"deviceaddress\":\"$uid\"}" -H "Content-Type:application/json" -H "developerkey:$developerkey" -H "token:$token")
    checkAPIResult "$deleteURL $uid" "$result"

    #    printf "\n\n"
}
######### End Delete device #########

######### Delete device by UID #########
deleteDeviceByUid()
{
    uid="$1"
    resp=$(curl ${CURL_OPTS} 'POST' $deleteURL -d "{\"deviceaddress\":\"$uid\"}" -H "Content-Type:application/json" -H "developerkey:$developerkey" -H "token:$token")
    checkAPIResult "$deleteURL $uid" "$resp"
}
######### End Delete device by UID #########

#############################
debug()
{
    if [ "$DEBUG" = "1" ]; then
	echo "$1"
    fi
}

#############################
makeConnection()
{
    PROTOCOL=$1
    PORT=$2
    alias=$3
    CUSTOM=2	# forces port to be written to conf file
    CONNECTD_PORT=Connectd"$PROTOCOL""$PORT"
    debug "$CONNECTD_PORT"
    if [ -f "$CONNECTD_DIR"/"$CONNECTD_PORT".conf ]; then
        echo "A $PROTOCOL service has already been configured on port $PORT."
        echo "Skipping $alias..."
    else
        configureConnection "skipIfDuplicateName"
    fi
}

############################

configureConnection()
{
    installEnablement
    installStartStop
    # REGISTERSERVICE controls (in connectd_options) whether or not services are registered at the time of installation
    if [ "$REGISTERSERVICE" = "1" ]; then
    	fetchUID
    	checkUID
    	preregisterUID
    	registerDevice

    	if [ "$error" != "DuplicateName:" ]; then
    	    overridePort
    	    startService
	    # there should only be one UDP listener startup regardless of the number of services
	    # the startup script will only start one instance
	    "$BIN_DIR"/connectd_schannel start > /dev/null
	else
	    if [ "$1" = "skipIfDuplicateName" ]; then
                echo "Duplicate Name!"
            fi
        fi
    fi
}

######### Interactive Install #########
interactiveInstall()
{
    echo
    displayVersion "$1"
    checkForRoot
    checkForUtilities
    platformDetection
    connectdCompatibility
    askRegisterLogin
    checkForUpdate
    checkForDeviceName
    # main menu loop 
    menuLoop
}
######### End Interactive Install #########


#======== utility functions used in installers

#----------------------------------------------------------
# JSON parse (very simplistic):  get value frome key $2 in buffer $1,  values or keys must not have the characters {}[", 
#   and the key must not have : in it
#
#  Example:
#   value=$(jsonval "$json_buffer" "$key") 
#                                                   
jsonval()                                              
{
    temp=$(echo "$1" | sed -e 's/[{}\"]//g' | sed -e 's/,/\n/g' | grep -w ${GREPFLAGS} "$2" | cut -d"[" -f2- | cut -d":" -f2-)
    echo "${temp##*|}"         
}                                                   

#----------------------------------------------------------
jsonvalx()
{
    temp=$(echo "$1" | sed -e 's/[{}"]//g' -e "s/,/\\$liblf/g" | grep ${GREPFLAGS} "$2" | cut -d":" -f2-)
    echo "${temp}"    
}

#----------------------------------------------------------
getJSONSecret()
{
# strip out all colons, break at commas, get rid of brackets and quotes

    temp=$(echo "$1" | sed -e 's/,/\'\n'/g' | sed -e 's/[{}"]//g' | grep -m 1 "$2" | awk -F "$2:" '{print $2}' | sed 's/://g')
    echo "${temp}"
}

######### Ask Function #########
ask()
{
    echo
    while true; do
	if [ "${2:-}" = "Y" ]; then
	    prompt="Y/n"
	    default=Y
	elif [ "${2:-}" = "N" ]; then
	    prompt="y/N"
	    default=N
	else
	    prompt="y/n"
	    default=
	fi
	# Ask the question
        echo "$1 [$prompt] "
	read REPLY
	# Default?
	if [ -z "$REPLY" ]; then
	    REPLY=$default
	fi
	# Check if the reply is valid
	case "$REPLY" in
	    Y*|y*) return 0 ;;
	    N*|n*) return 1 ;;
	esac
    done
}
######### End Ask Function #########

############# validate input - check $1 against tr control string $2

validateInput()
{
# Comb out invalid characters from input and assign to new variable
export VAR_CLEAN="$(echo "$1" | tr -cd "$2" )"
# if the before and after are the same, then there were no bad characters
if [ "${VAR_CLEAN}" = "$1" ]; then
   echo 0
else
   echo 1
fi
}

############# end of validate input


#======== end of utility functions used in installers


